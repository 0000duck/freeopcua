//
// DO NOT EDIT THIS FILE!
// It is automatically generated from opcfoundation.org schemas.
//

#pragma once

inline AttributeID GetAttributeIDOptionValue(const po::variables_map& vm)
  {
    const std::string name = vm[OPTION_ATTRIBUTE].as<std::string>();
    if (name == "node id")
    {
      return AttributeID::NodeId;
    }
    if (name == "node class")
    {
      return AttributeID::NodeClass;
    }
    if (name == "browse name")
    {
      return AttributeID::BrowseName;
    }
    if (name == "display name")
    {
      return AttributeID::DisplayName;
    }
    if (name == "description")
    {
      return AttributeID::Description;
    }
    if (name == "write mask")
    {
      return AttributeID::WriteMask;
    }
    if (name == "user write mask")
    {
      return AttributeID::UserWriteMask;
    }
    if (name == "is abstract")
    {
      return AttributeID::IsAbstract;
    }
    if (name == "symmetric")
    {
      return AttributeID::Symmetric;
    }
    if (name == "inverse name")
    {
      return AttributeID::InverseName;
    }
    if (name == "contains no loops")
    {
      return AttributeID::ContainsNoLoops;
    }
    if (name == "event notifier")
    {
      return AttributeID::EventNotifier;
    }
    if (name == "value")
    {
      return AttributeID::Value;
    }
    if (name == "data type")
    {
      return AttributeID::DataType;
    }
    if (name == "value rank")
    {
      return AttributeID::ValueRank;
    }
    if (name == "array dimensions")
    {
      return AttributeID::ArrayDimensions;
    }
    if (name == "access level")
    {
      return AttributeID::AccessLevel;
    }
    if (name == "user access level")
    {
      return AttributeID::UserAccessLevel;
    }
    if (name == "minimum sampling interval")
    {
      return AttributeID::MinimumSamplingInterval;
    }
    if (name == "historizing")
    {
      return AttributeID::Historizing;
    }
    if (name == "executable")
    {
      return AttributeID::Executable;
    }
    if (name == "user executable")
    {
      return AttributeID::UserExecutable;
    }

    throw std::logic_error(std::string("Unknown AttributeID: ") + name);
  };

