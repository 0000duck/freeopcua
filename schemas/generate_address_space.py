"""
Generate address space c++ code from xml file specification
"""
import sys

import xml.etree.ElementTree as ET

def writecode(*args):
    sys.stdout.write(" ".join(args) + "\n")

def make_header():
    writecode( '''
// DO NOT EDIT THIS FILE!
// It is automatically generated from opcfoundation.org schemas.
//

#include <opc/ua/server/standard_namespace.h>

#include <opc/ua/protocol/string_utils.h>
#include <opc/common/addons_core/addon.h>
#include <opc/ua/protocol/node_classes.h>
#include <opc/ua/protocol/strings.h>
#include <opc/ua/protocol/variable_access_level.h>
#include <opc/ua/services/node_management.h>

#include <algorithm>
#include <iostream>
#include <map>

namespace
{
    using namespace OpcUa;

    class StandardNamespace
    {
    public:
      StandardNamespace(OpcUa::NodeManagementServices& registry, bool debug)
        : Registry(registry)
        , Debug(debug)
      {
      }

      void Fill()
      {


''')

def make_footer():
    writecode( '''
    }

     private:
      OpcUa::NodeManagementServices& Registry;
      const bool Debug;

   };

} // namespace

namespace OpcUa
{
  namespace Server
  {

    void FillStandardNamespace(OpcUa::NodeManagementServices& registry, bool debug)
    {
      StandardNamespace ns(registry, debug);
      ns.Fill();
    }

  } // namespace UaServer
} // namespace OpcUa
''')

class ObjectStruct(object):
    def __init__(self):
        self.nodetype = None
        self.nodeid = None
        self.browsename = None 
        self.displayname = None
        self.symname = None
        self.parent = None
        self.parentlink = None
        self.desc = ""
        self.typedef = None
        self.refs = []
        self.nodeclass = None

        #variable
        self.datatype = None
        self.rank = -1 # checl default value
        self.value = []
        self.dimensions = None

        #referencetype
        self.inversename = ""
        self.abstract = "false"
        self.symmetric = "false"

        #datatype
        self.definition = []


class RefStruct():
    def __init__(self):
        self.reftype = None
        self.forward = "true"
        self.target = None

def parse_node(child):
    obj = ObjectStruct()
    obj.nodetype = child.tag[53:]
    obj.nodeid = child.attrib["NodeId"]
    obj.browsename = child.attrib["BrowseName"]
    if "Symbolicname" in child.attrib: obj.symname = child.attrib["SymbolicName"]
    if "ParentNodeId" in child.attrib: obj.parent = child.attrib["ParentNodeId"]
    if "DataType" in child.attrib: obj.datatype = child.attrib["DataType"]
    obj.displayname = obj.browsename#FIXME
    for el in child:
        if el.tag[51:] == "DisplayName":
            obj.displayname = el.text
        elif el.tag[51:] == "Description":
            obj.desc = el.text
        elif el.tag[51:] == "References":
            for ref in el:
                #writecode("ref", ref, "IsForward" in ref, ref.text )
                if ref.attrib["ReferenceType"] == "HasTypeDefinition":
                    obj.typedef = ref.text
                elif "IsForward" in ref.attrib and ref.attrib["IsForward"] == "false":
                    #if obj.parent:
                        #sys.stderr.write("Parent is already set with: "+ obj.parent + " " + ref.text + "\n") 
                    obj.parent = ref.text
                    obj.parentlink = ref.attrib["ReferenceType"]
                else:
                    struct = RefStruct()
                    if "IsForward" in ref.attrib: struct.forward = ref.attrib["IsForward"]
                    struct.target = ref.text
                    struct.reftype = ref.attrib["ReferenceType"] 
                    obj.refs.append(struct)

        elif el.tag[51:] == "Value":
            for val in el:
                tag = val.tag[47:]
                if tag == "Int32":
                    obj.value.append("(int32_t) " + val.text)
                elif tag == "UInt32":
                    obj.value.append("(uint32_t) " + val.text)
                elif tag in ( 'ByteString', 'String'):
                    mytext = val.text.replace('\n','').replace('\r','')
                    obj.value.append('+"{}"'.format(mytext))
                elif tag == "ListOfExtensionObject":
                    pass
                elif tag == "ListOfLocalizedText":
                    pass
                else:
                    writecode("Missing type: ", tag)
        elif el.tag[51:] == "InverseName":
            obj.inversename = el.text
        elif el.tag[51:] == "Definition":
            for field in el:
                obj.definition.append(field)
        else:
            syst.sterr.write("Not implemented tag: "+ str(el) + "\n")
    return obj

def make_node_code(obj, indent):
    writecode(indent, 'AddNodesItem node;')
    writecode(indent, 'node.RequestedNewNodeID = ToNodeID("{}");'.format(obj.nodeid))
    writecode(indent, 'node.BrowseName = ToQualifiedName("{}");'.format(obj.browsename))
    writecode(indent, 'node.Class = NodeClass::{};'.format(obj.nodetype))
    if obj.parent: writecode(indent, 'node.ParentNodeId = ToNodeID("{}");'.format(obj.parent))
    if obj.parent: writecode(indent, 'node.ReferenceTypeId = {};'.format(to_ref_type(obj.parentlink)))
    if obj.typedef: writecode(indent, 'node.TypeDefinition = ToNodeID("{}");'.format(obj.typedef))

def make_object_code(obj):
    indent = "       "
    writecode(indent)
    writecode(indent, "{")
    make_node_code(obj, indent)
    writecode(indent, 'ObjectAttributes attrs;')
    if obj.desc: writecode(indent, 'attrs.Description = LocalizedText("{}");'.format(obj.desc))
    writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
    writecode(indent, 'node.Attributes = attrs;')
    writecode(indent, 'Registry.AddNodes(std::vector<AddNodesItem>{node});')
    writecode(indent)
    make_refs_code(obj, indent)
    writecode(indent, "}")

def to_data_type(nodeid):
    if not nodeid:
        return "ObjectID::String"
    if "=" in nodeid:
        return 'ToNodeID("{}")'.format(nodeid)
    else:
        return 'ObjectID::{}'.format(nodeid)

def to_ref_type(nodeid):
    if "=" in nodeid:
        return 'ToNodeID("{}")'.format(nodeid)
    else:
        return 'ReferenceID::{}'.format(nodeid)


def make_variable_code(obj):
    indent = "       "
    writecode(indent)
    writecode(indent, "{")
    make_node_code(obj, indent)
    writecode(indent, 'VariableAttributes attrs;')
    if obj.desc: writecode(indent, 'attrs.Description = LocalizedText("{}");'.format(obj.desc))
    writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
    writecode(indent, 'attrs.Type = {};'.format(to_data_type(obj.datatype)))
    if obj.value and len(obj.value) == 1: writecode(indent, 'attrs.Value = {};'.format(obj.value[0]))
    if obj.rank: writecode(indent, 'attrs.Rank = {};'.format(obj.rank))
    writecode(indent, 'node.Attributes = attrs;')
    writecode(indent, 'Registry.AddNodes(std::vector<AddNodesItem>{node});')
    writecode(indent)
    make_refs_code(obj, indent)
    writecode(indent, "}")


def make_reference_code(obj):
    indent = "       "
    writecode(indent)
    writecode(indent, "{")
    make_node_code(obj, indent)
    writecode(indent, 'ReferenceTypeAttributes attrs;')
    if obj.desc: writecode(indent, 'attrs.Description = LocalizedText("{}");'.format(obj.desc))
    writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
    if obj. inversename: writecode(indent, 'attrs.InverseName = LocalizedText("{}");'.format(obj.inversename))
    if obj.abstract: writecode(indent, 'attrs.IsAbstract = {};'.format(obj.abstract))
    if obj.symmetric: writecode(indent, 'attrs.Symmetric = {};'.format(obj.symmetric))
    writecode(indent, 'node.Attributes = attrs;')
    writecode(indent, 'Registry.AddNodes(std::vector<AddNodesItem>{node});')
    writecode(indent)
    make_refs_code(obj, indent)
    writecode(indent, "}")

def make_datatype_code(obj):
    indent = "       "
    writecode(indent)
    writecode(indent, "{")
    make_node_code(obj, indent)
    writecode(indent, 'DataTypeAttributes attrs;')
    if obj.desc: writecode(indent, u'attrs.Description = LocalizedText("{}");'.format(obj.desc.encode('ascii', 'replace')))
    writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
    if obj.abstract: writecode(indent, 'attrs.IsAbstract = {};'.format(obj.abstract))
    writecode(indent, 'node.Attributes = attrs;')
    writecode(indent, 'Registry.AddNodes(std::vector<AddNodesItem>{node});')
    writecode(indent)
    make_refs_code(obj, indent)
    writecode(indent, "}")

def make_refs_code(obj, indent):
    if not obj.refs:
        return
    writecode(indent, "std::vector<AddReferencesItem> refs;")
    for ref in obj.refs:
        writecode(indent, "{")
        writecode(indent, 'AddReferencesItem ref;')
        writecode(indent, 'ref.IsForward = true;')
        writecode(indent, 'ref.ReferenceTypeId = {};'.format(to_ref_type(ref.reftype)))
        writecode(indent, 'ref.SourceNodeID = ToNodeID("{}");'.format(obj.nodeid))
        writecode(indent, 'ref.TargetNodeClass = NodeClass::DataType;')
        writecode(indent, 'ref.TargetNodeID = ToNodeID("{}");'.format(ref.target))
        writecode(indent, "refs.push_back(ref);")
        writecode(indent, "}")
    writecode(indent, 'Registry.AddReferences(refs);')


if __name__ == "__main__":
    if len(sys.argv) > 1:
        xmlpath = sys.argv[1]
    else:
        xmlpath = 'Opc.Ua.NodeSet2.xml'
    make_header()
    tree = ET.parse(xmlpath)
    root = tree.getroot()
    for child in root:
        if child.tag[51:] in ('UAObject', 'UAObjectType'):
            node = parse_node(child)
            make_object_code(node)
        elif child.tag[51:] in ('UAVariable', 'UAVariableType'):
            node = parse_node(child)
            make_variable_code(node)
        elif child.tag[51:] == 'UAReferenceType':
            node = parse_node(child)
            make_reference_code(node)
        elif child.tag[51:] == 'UADataType':
            node = parse_node(child)
            make_datatype_code(node)
    make_footer()

