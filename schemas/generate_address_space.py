"""
Generate address space c++ code from xml file specification
"""
import sys

from IPython import embed

import xml.etree.ElementTree as ET

class ObjectStruct(object):
    def __init__(self):
        self.nodetype = None
        self.nodeid = None
        self.browsename = None 
        self.displayname = None
        self.symname = None
        self.parent = None
        self.parentlink = None
        self.desc = ""
        self.typedef = None
        self.refs = []
        self.nodeclass = None

        #variable
        self.datatype = None
        self.rank = -1 # checl default value
        self.value = []
        self.dimensions = None

        #referencetype
        self.inversename = ""
        self.abstract = "false"
        self.symmetric = "false"

        #datatype
        self.definition = []


class RefStruct():
    def __init__(self):
        self.reftype = None
        self.forward = "true"
        self.target = None


class CodeGenerator(object):
    def __init__(self, input_path, output_path):
        self.input_path = input_path
        self.output_path = output_path
        self.output_file = None
        self.part = self.input_path.split(".")[-2]

    def run(self):
        self.output_file = open(self.output_path, "w")
        self.make_header()
        tree = ET.parse(xmlpath)
        root = tree.getroot()
        for child in root:
            if child.tag[51:] in ('UAObject', 'UAObjectType'):
                node = self.parse_node(child)
                self.make_object_code(node)
            elif child.tag[51:] in ('UAVariable', 'UAVariableType'):
                node = self.parse_node(child)
                self.make_variable_code(node)
            elif child.tag[51:] == 'UAReferenceType':
                node = self.parse_node(child)
                self.make_reference_code(node)
            elif child.tag[51:] == 'UADataType':
                node = self.parse_node(child)
                self.make_datatype_code(node)
            else:
                sys.stderr.write("Not implemented node type: " + child.tag[51:] + "\n")
        self.make_footer()

    def writecode(self, *args):
        self.output_file.write(" ".join(args) + "\n")

    def make_header(self, ):
        self.writecode('''
// DO NOT EDIT THIS FILE!
// It is automatically generated from opcfoundation.org schemas.
//

#include "standard_address_space_parts.h"
#include <opc/ua/protocol/string_utils.h>
#include <opc/common/addons_core/addon.h>
#include <opc/ua/protocol/node_classes.h>
#include <opc/ua/protocol/strings.h>
#include <opc/ua/protocol/variable_access_level.h>
#include <opc/ua/services/node_management.h>

#include <algorithm>
#include <iostream>
#include <map>

namespace OpcUa
{
  void CreateAddressSpace%s(OpcUa::NodeManagementServices& registry)
  {''' % (self.part))

    def make_footer(self, ):
        self.writecode('''
   }

} // namespace
    ''')


    def parse_node(self, child):
        obj = ObjectStruct()
        obj.nodetype = child.tag[53:]
        obj.nodeid = child.attrib["NodeId"]
        obj.browsename = child.attrib["BrowseName"]
        if "Symbolicname" in child.attrib: obj.symname = child.attrib["SymbolicName"]
        if "ParentNodeId" in child.attrib: obj.parent = child.attrib["ParentNodeId"]
        if "DataType" in child.attrib: obj.datatype = child.attrib["DataType"]
        obj.displayname = obj.browsename#FIXME
        for el in child:
            if el.tag[51:] == "DisplayName":
                obj.displayname = el.text
            elif el.tag[51:] == "Description":
                obj.desc = el.text
            elif el.tag[51:] == "References":
                for ref in el:
                    #self.writecode("ref", ref, "IsForward" in ref, ref.text )
                    if ref.attrib["ReferenceType"] == "HasTypeDefinition":
                        obj.typedef = ref.text
                    elif "IsForward" in ref.attrib and ref.attrib["IsForward"] == "false":
                        #if obj.parent:
                            #sys.stderr.write("Parent is already set with: "+ obj.parent + " " + ref.text + "\n") 
                        obj.parent = ref.text
                        obj.parentlink = ref.attrib["ReferenceType"]
                    else:
                        struct = RefStruct()
                        if "IsForward" in ref.attrib: struct.forward = ref.attrib["IsForward"]
                        struct.target = ref.text
                        struct.reftype = ref.attrib["ReferenceType"] 
                        obj.refs.append(struct)

            elif el.tag[51:] == "Value":
                for val in el:
                    tag = val.tag[47:]
                    if tag == "Int32":
                        obj.value.append("(int32_t) " + val.text)
                    elif tag == "UInt32":
                        obj.value.append("(uint32_t) " + val.text)
                    elif tag in ('ByteString', 'String'):
                        mytext = val.text.replace('\n', '').replace('\r', '')
                        obj.value.append('+"{}"'.format(mytext))
                    elif tag == "ListOfExtensionObject":
                        pass
                    elif tag == "ListOfLocalizedText":
                        pass
                    else:
                        self.writecode("Missing type: ", tag)
            elif el.tag[51:] == "InverseName":
                obj.inversename = el.text
            elif el.tag[51:] == "Definition":
                for field in el:
                    obj.definition.append(field)
            else:
                sys.stderr.write("Not implemented tag: "+ str(el) + "\n")
        return obj

    def make_node_code(self, obj, indent):
        self.writecode(indent, 'AddNodesItem node;')
        self.writecode(indent, 'node.RequestedNewNodeID = ToNodeID("{}");'.format(obj.nodeid))
        self.writecode(indent, 'node.BrowseName = ToQualifiedName("{}");'.format(obj.browsename))
        self.writecode(indent, 'node.Class = NodeClass::{};'.format(obj.nodetype))
        if obj.parent: self.writecode(indent, 'node.ParentNodeId = ToNodeID("{}");'.format(obj.parent))
        if obj.parent: self.writecode(indent, 'node.ReferenceTypeId = {};'.format(self.to_ref_type(obj.parentlink)))
        if obj.typedef: self.writecode(indent, 'node.TypeDefinition = ToNodeID("{}");'.format(obj.typedef))

    def make_object_code(self, obj):
        indent = "       "
        self.writecode(indent)
        self.writecode(indent, "{")
        self.make_node_code(obj, indent)
        self.writecode(indent, 'ObjectAttributes attrs;')
        if obj.desc: self.writecode(indent, 'attrs.Description = LocalizedText("{}");'.format(obj.desc))
        self.writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
        self.writecode(indent, 'node.Attributes = attrs;')
        self.writecode(indent, 'registry.AddNodes(std::vector<AddNodesItem>{node});')
        self.make_refs_code(obj, indent)
        self.writecode(indent, "}")

    def to_data_type(self, nodeid):
        if not nodeid:
            return "ObjectID::String"
        if "=" in nodeid:
            return 'ToNodeID("{}")'.format(nodeid)
        else:
            return 'ObjectID::{}'.format(nodeid)

    def to_ref_type(self, nodeid):
        if "=" in nodeid:
            return 'ToNodeID("{}")'.format(nodeid)
        else:
            return 'ReferenceID::{}'.format(nodeid)


    def make_variable_code(self, obj):
        indent = "       "
        self.writecode(indent)
        self.writecode(indent, "{")
        self.make_node_code(obj, indent)
        self.writecode(indent, 'VariableAttributes attrs;')
        if obj.desc: self.writecode(indent, 'attrs.Description = LocalizedText("{}");'.format(obj.desc))
        self.writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
        self.writecode(indent, 'attrs.Type = {};'.format(self.to_data_type(obj.datatype)))
        if obj.value and len(obj.value) == 1: self.writecode(indent, 'attrs.Value = {};'.format(obj.value[0]))
        if obj.rank: self.writecode(indent, 'attrs.Rank = {};'.format(obj.rank))
        self.writecode(indent, 'node.Attributes = attrs;')
        self.writecode(indent, 'registry.AddNodes(std::vector<AddNodesItem>{node});')
        self.make_refs_code(obj, indent)
        self.writecode(indent, "}")


    def make_reference_code(self, obj):
        indent = "       "
        self.writecode(indent)
        self.writecode(indent, "{")
        self.make_node_code(obj, indent)
        self.writecode(indent, 'ReferenceTypeAttributes attrs;')
        if obj.desc: self.writecode(indent, 'attrs.Description = LocalizedText("{}");'.format(obj.desc))
        self.writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
        if obj. inversename: self.writecode(indent, 'attrs.InverseName = LocalizedText("{}");'.format(obj.inversename))
        if obj.abstract: self.writecode(indent, 'attrs.IsAbstract = {};'.format(obj.abstract))
        if obj.symmetric: self.writecode(indent, 'attrs.Symmetric = {};'.format(obj.symmetric))
        self.writecode(indent, 'node.Attributes = attrs;')
        self.writecode(indent, 'registry.AddNodes(std::vector<AddNodesItem>{node});')
        self.make_refs_code(obj, indent)
        self.writecode(indent, "}")

    def make_datatype_code(self, obj):
        indent = "       "
        self.writecode(indent)
        self.writecode(indent, "{")
        self.make_node_code(obj, indent)
        self.writecode(indent, 'DataTypeAttributes attrs;')
        if obj.desc: self.writecode(indent, u'attrs.Description = LocalizedText("{}");'.format(obj.desc.encode('ascii', 'replace')))
        self.writecode(indent, 'attrs.DisplayName = LocalizedText("{}");'.format(obj.displayname))
        if obj.abstract: self.writecode(indent, 'attrs.IsAbstract = {};'.format(obj.abstract))
        self.writecode(indent, 'node.Attributes = attrs;')
        self.writecode(indent, 'registry.AddNodes(std::vector<AddNodesItem>{node});')
        self.make_refs_code(obj, indent)
        self.writecode(indent, "}")

    def make_refs_code(self, obj, indent):
        if not obj.refs:
            return
        self.writecode(indent, "std::vector<AddReferencesItem> refs;")
        for ref in obj.refs:
            self.writecode(indent, "{")
            self.writecode(indent, 'AddReferencesItem ref;')
            self.writecode(indent, 'ref.IsForward = true;')
            self.writecode(indent, 'ref.ReferenceTypeId = {};'.format(self.to_ref_type(ref.reftype)))
            self.writecode(indent, 'ref.SourceNodeID = ToNodeID("{}");'.format(obj.nodeid))
            self.writecode(indent, 'ref.TargetNodeClass = NodeClass::DataType;')
            self.writecode(indent, 'ref.TargetNodeID = ToNodeID("{}");'.format(ref.target))
            self.writecode(indent, "refs.push_back(ref);")
            self.writecode(indent, "}")
        self.writecode(indent, 'registry.AddReferences(refs);')


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(sys.argv)
        print("usage: generate_address_space.py xml_input_file cpp_output_file")
        sys.exit(1)
    else:
        xmlpath = sys.argv[1] 
        cpppath = sys.argv[2]
    sys.stderr.write("Generating C++ {} for XML file {}".format(cpppath, xmlpath) + "\n")
    c = CodeGenerator(xmlpath, cpppath)
    c.run()

