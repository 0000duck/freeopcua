<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uripp: uripp Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>uripp Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
URI library. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1authority.html">authority</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">URI authority component (without userinfo).  <a href="classuripp_1_1authority.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1domain__name.html">domain_name</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Domain name.  <a href="classuripp_1_1domain__name.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1fragment.html">fragment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">URI fragment component.  <a href="classuripp_1_1fragment.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1ip__address.html">ip_address</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IP address.  <a href="classuripp_1_1ip__address.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ipv6_address</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html">path</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">URI path component.  <a href="classuripp_1_1path.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1query.html">query</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">URI query component.  <a href="classuripp_1_1query.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1scheme.html">scheme</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">URI scheme component.  <a href="classuripp_1_1scheme.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1uri.html">uri</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uniform Resource Identifier (URI) reference.  <a href="classuripp_1_1uri.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp_1_1urisyn.html">urisyn</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">URI syntax declarations. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc7d142397d1d68107e0c86da592b18a"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="fc7d142397d1d68107e0c86da592b18a" args="(std::ostream &amp;os, const authority &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#fc7d142397d1d68107e0c86da592b18a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1authority.html">authority</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out URI authority. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#b18b3429a3a5101107579f81ae0a1950">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1authority.html">authority</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d3254af34f8f539e761d937bc596756"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="1d3254af34f8f539e761d937bc596756" args="(std::ostream &amp;os, const domain_name &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#1d3254af34f8f539e761d937bc596756">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1domain__name.html">domain_name</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out domain name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#1182f9d97e3143a4977c1160c1679168">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1domain__name.html">domain_name</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#056d05491464e3826416bb4aea6ed196">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1fragment.html">fragment</a> &amp;v, std::string *errs=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3d8bf426333be657098db50844194fe"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="f3d8bf426333be657098db50844194fe" args="(std::ostream &amp;os, const fragment &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#f3d8bf426333be657098db50844194fe">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1fragment.html">fragment</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out fragment encoding. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5731f36ed6c3c0bf3ab0fed90e5c8796"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="5731f36ed6c3c0bf3ab0fed90e5c8796" args="(std::ostream &amp;os, const ip_address &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#5731f36ed6c3c0bf3ab0fed90e5c8796">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1ip__address.html">ip_address</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out IP address. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#8b1ac1794f999177bdce39d3759273d2">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1ip__address.html">ip_address</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2423a0e8321f7d0f3118a3152e0a2547"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="2423a0e8321f7d0f3118a3152e0a2547" args="(std::ostream &amp;os, const ipv6_address &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#2423a0e8321f7d0f3118a3152e0a2547">operator&lt;&lt;</a> (std::ostream &amp;os, const ipv6_address &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out IP v6 address. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#e548b91cf543a410c29f1825084f9267">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, ipv6_address &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#b01d4ea60303eaa2f450fc5b3d8b82c0">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1path.html">path</a> &amp;v, std::string *errs=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#b3ce82f5cb52db3976089beb08f8b18f">convert</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#9c014ddc0c1a50ff304ce6c3c344ff7f">convert</a> (const std::string &amp;s, <a class="el" href="classuripp_1_1path.html">path</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd025be34d842d9238041f3e0df317af"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="cd025be34d842d9238041f3e0df317af" args="(std::ostream &amp;os, const path &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#cd025be34d842d9238041f3e0df317af">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1path.html">path</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out path encoding. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#da765d4e617b967eeb0ba58e17d0a1d5">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1query.html">query</a> &amp;v, std::string *errs=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5e35dfb3c3f3923dc0ccb46a885db48b"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="5e35dfb3c3f3923dc0ccb46a885db48b" args="(std::ostream &amp;os, const query &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#5e35dfb3c3f3923dc0ccb46a885db48b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1query.html">query</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out query encoding. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f6736f4b31b9fbaac9df22612670bdc"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="7f6736f4b31b9fbaac9df22612670bdc" args="(std::ostream &amp;os, const scheme &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#7f6736f4b31b9fbaac9df22612670bdc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1scheme.html">scheme</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out URI scheme. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#13bb1ec1a31e430d0e433c133f363826">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1scheme.html">scheme</a> &amp;v, char *endc=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#95089eb67b0ab1e26c928bb2afb62715">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1uri.html">uri</a> &amp;v, std::string *errs=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9fa125772bd47c335dfd985e23aa915b"></a><!-- doxytag: member="uripp::operator&lt;&lt;" ref="9fa125772bd47c335dfd985e23aa915b" args="(std::ostream &amp;os, const uri &amp;v)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#9fa125772bd47c335dfd985e23aa915b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classuripp_1_1uri.html">uri</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream out URI encoding. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c53c15f7aabd7cd6689dbbe5c035c78"></a><!-- doxytag: member="uripp::convert" ref="0c53c15f7aabd7cd6689dbbe5c035c78" args="(bool v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#0c53c15f7aabd7cd6689dbbe5c035c78">convert</a> (bool v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bool to string, true="1", false="0" <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c5f2b0ade8a93f68226889fdcd0c968"></a><!-- doxytag: member="uripp::convert" ref="8c5f2b0ade8a93f68226889fdcd0c968" args="(int v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#8c5f2b0ade8a93f68226889fdcd0c968">convert</a> (int v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">int to string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="881d2ae1beed441a8b130144a4bea6e5"></a><!-- doxytag: member="uripp::convert" ref="881d2ae1beed441a8b130144a4bea6e5" args="(unsigned int v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#881d2ae1beed441a8b130144a4bea6e5">convert</a> (unsigned int v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">uint to string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34cf9e905909f6e808cf8fbb50e5c038"></a><!-- doxytag: member="uripp::convert" ref="34cf9e905909f6e808cf8fbb50e5c038" args="(unsigned long int v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#34cf9e905909f6e808cf8fbb50e5c038">convert</a> (unsigned long int v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unsigned long int to string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="091d30c1896ad533161254ea9b4ab005"></a><!-- doxytag: member="uripp::convert" ref="091d30c1896ad533161254ea9b4ab005" args="(long long int v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#091d30c1896ad533161254ea9b4ab005">convert</a> (long long int v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">long long int to string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10308db248fb5deb38605cfa2fbc28da"></a><!-- doxytag: member="uripp::convert" ref="10308db248fb5deb38605cfa2fbc28da" args="(unsigned long long int v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#10308db248fb5deb38605cfa2fbc28da">convert</a> (unsigned long long int v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unsigned long long int to string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6581b49f68df49c346c79f1b7a1f5cc8"></a><!-- doxytag: member="uripp::convert" ref="6581b49f68df49c346c79f1b7a1f5cc8" args="(ptrdiff_t v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#6581b49f68df49c346c79f1b7a1f5cc8">convert</a> (ptrdiff_t v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ptrdiff_t to string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c4d752244ac9e9d4cae5f53267ddcca"></a><!-- doxytag: member="uripp::convert" ref="1c4d752244ac9e9d4cae5f53267ddcca" args="(double v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#1c4d752244ac9e9d4cae5f53267ddcca">convert</a> (double v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">double to string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89dc13191093d716e6941b5f41af6a00"></a><!-- doxytag: member="uripp::convert" ref="89dc13191093d716e6941b5f41af6a00" args="(const std::string &amp;v)" -->
std::string URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#89dc13191093d716e6941b5f41af6a00">convert</a> (const std::string &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">string to trimmed string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#4fd3e4f9ade8ef69118af7121eeacba2">convert</a> (const char *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#f9efbcbc78af4bcf0d5ae78cc30f61c5">convert</a> (const std::string &amp;s, bool &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#ef3b08ed205eefb6396c83116603af45">convert</a> (const std::string &amp;s, int &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#498304268f82e9895792fddcf08abfdc">convert</a> (const std::string &amp;s, unsigned int &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#8c2c280a8fe6369de53e7a90a8288b51">convert</a> (const std::string &amp;s, unsigned long int &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#2a54b58322d222be464c94c86d6bd623">convert</a> (const std::string &amp;s, long long int &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#025b4f6dc926670b81563974fc7ae933">convert</a> (const std::string &amp;s, unsigned long long int &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#e5269f51d3787ec1a0eb839784b1dba0">convert</a> (const std::string &amp;s, double &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#cbd143a3a240e2fb57eda08e9beb1473">convert</a> (const std::string &amp;s, std::string &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#c022bda4680769c731e205c24133824d">isspaces</a> (const char *s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#a09e4869830939777e1bc2d2cd850d4e">parse_hex</a> (const std::string &amp;s, size_t pos, char &amp;chr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b30adb81307394b78c9dccd9b6b1a55d"></a><!-- doxytag: member="uripp::append_hex" ref="b30adb81307394b78c9dccd9b6b1a55d" args="(char v, std::string &amp;s)" -->
void URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuripp.html#b30adb81307394b78c9dccd9b6b1a55d">append_hex</a> (char v, std::string &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the char v to hex and add the 2 chars to the end of s. <br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b18b3429a3a5101107579f81ae0a1950"></a><!-- doxytag: member="uripp::parse" ref="b18b3429a3a5101107579f81ae0a1950" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, authority &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">authority &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse URI authority, returning whether found or not and advancing first and setting authority if found. Does not skip leading space. 
</div>
</div><p>
<a class="anchor" name="1182f9d97e3143a4977c1160c1679168"></a><!-- doxytag: member="uripp::parse" ref="1182f9d97e3143a4977c1160c1679168" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, domain_name &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">domain_name &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse domain name, returning whether found or not and advancing first and setting name if found. Does not skip leading space. 
</div>
</div><p>
<a class="anchor" name="056d05491464e3826416bb4aea6ed196"></a><!-- doxytag: member="uripp::parse" ref="056d05491464e3826416bb4aea6ed196" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, fragment &amp;v, std::string *errs=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fragment &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>errs</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse URI fragment, returning whether found or not and advancing first and setting fragment if found. Does not skip leading space.<p>
If <code>errs</code> is specified the following take place:<ul>
<li>
Errors in decoding the string do not cause an immediate false return and and error message is reported in the error string <code>errs</code>. The string is used without decoding (i.e. assumes an unencoded ''). </li>
</ul>

</div>
</div><p>
<a class="anchor" name="8b1ac1794f999177bdce39d3759273d2"></a><!-- doxytag: member="uripp::parse" ref="8b1ac1794f999177bdce39d3759273d2" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, ip_address &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ip_address &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse IP address, returning whether found or not and advancing first and setting address if found. Does not skip leading space. 
</div>
</div><p>
<a class="anchor" name="e548b91cf543a410c29f1825084f9267"></a><!-- doxytag: member="uripp::parse" ref="e548b91cf543a410c29f1825084f9267" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, ipv6_address &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ipv6_address &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse IP v6 address, returning whether found or not and advancing first and setting address if found. Does not skip leading space. 
</div>
</div><p>
<a class="anchor" name="b01d4ea60303eaa2f450fc5b3d8b82c0"></a><!-- doxytag: member="uripp::parse" ref="b01d4ea60303eaa2f450fc5b3d8b82c0" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, path &amp;v, std::string *errs=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>errs</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse URI path, returning whether found or not and advancing first and setting path if found. Does not skip leading space.<p>
If <code>errs</code> is specified the following take place:<ul>
<li>
Errors in decoding segments do not cause an immediate false return and and error message is reported in the error string <code>errs</code>. The segment is used without decoding (i.e. assumes an unencoded ''). </li>
</ul>

</div>
</div><p>
<a class="anchor" name="b3ce82f5cb52db3976089beb08f8b18f"></a><!-- doxytag: member="uripp::convert" ref="b3ce82f5cb52db3976089beb08f8b18f" args="(const path &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const path &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
URI path to string 
</div>
</div><p>
<a class="anchor" name="9c014ddc0c1a50ff304ce6c3c344ff7f"></a><!-- doxytag: member="uripp::convert" ref="9c014ddc0c1a50ff304ce6c3c344ff7f" args="(const std::string &amp;s, path &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to URI path, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="da765d4e617b967eeb0ba58e17d0a1d5"></a><!-- doxytag: member="uripp::parse" ref="da765d4e617b967eeb0ba58e17d0a1d5" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, query &amp;v, std::string *errs=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">query &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>errs</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse URI query, returning whether found or not and advancing first and setting query if found. Does not skip leading space.<p>
If <code>errs</code> is specified the following take place:<ul>
<li>
Errors in parsing subcomponents, after the first, do not cause an immediate false return and errors messages are reported in the error string <code>errs</code>. </li>
<li>
Errors are handled as follows:<ul>
<li>
Key-value pairs with an empty key are ignored. </li>
<li>
Keys with missing '=' are ignored. </li>
<li>
Errors decoding a key or value result in no decoding at all (i.e. assumes an unencoded ''). </li>
</ul>
</li>
</ul>

</div>
</div><p>
<a class="anchor" name="13bb1ec1a31e430d0e433c133f363826"></a><!-- doxytag: member="uripp::parse" ref="13bb1ec1a31e430d0e433c133f363826" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, scheme &amp;v, char *endc=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scheme &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>endc</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse URI scheme, returning whether found or not and advancing first and setting scheme and end char if found. Does not skip leading space. 
</div>
</div><p>
<a class="anchor" name="95089eb67b0ab1e26c928bb2afb62715"></a><!-- doxytag: member="uripp::parse" ref="95089eb67b0ab1e26c928bb2afb62715" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, uri &amp;v, std::string *errs=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uri &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>errs</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse URI, returning whether found or not and advancing first and setting URI if found. Does not skip leading space.<p>
If <code>errs</code> is specified parsing is more lax allowing decoding and other errors and setting <code>errs</code> with the error messages. See the individual component <code>parse</code> functions for details. 
</div>
</div><p>
<a class="anchor" name="4fd3e4f9ade8ef69118af7121eeacba2"></a><!-- doxytag: member="uripp::convert" ref="4fd3e4f9ade8ef69118af7121eeacba2" args="(const char *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
cstring to string 
</div>
</div><p>
<a class="anchor" name="f9efbcbc78af4bcf0d5ae78cc30f61c5"></a><!-- doxytag: member="uripp::convert" ref="f9efbcbc78af4bcf0d5ae78cc30f61c5" args="(const std::string &amp;s, bool &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to bool, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. The following, and their uppercase, qualify as true: 1, 't', "true", 'y', "yes", "on". Their complements are considered false, and all else error. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ef3b08ed205eefb6396c83116603af45"></a><!-- doxytag: member="uripp::convert" ref="ef3b08ed205eefb6396c83116603af45" args="(const std::string &amp;s, int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to int, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="498304268f82e9895792fddcf08abfdc"></a><!-- doxytag: member="uripp::convert" ref="498304268f82e9895792fddcf08abfdc" args="(const std::string &amp;s, unsigned int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to unsigned int, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8c2c280a8fe6369de53e7a90a8288b51"></a><!-- doxytag: member="uripp::convert" ref="8c2c280a8fe6369de53e7a90a8288b51" args="(const std::string &amp;s, unsigned long int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long int &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to size_t, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2a54b58322d222be464c94c86d6bd623"></a><!-- doxytag: member="uripp::convert" ref="2a54b58322d222be464c94c86d6bd623" args="(const std::string &amp;s, long long int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long int &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to long long int, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="025b4f6dc926670b81563974fc7ae933"></a><!-- doxytag: member="uripp::convert" ref="025b4f6dc926670b81563974fc7ae933" args="(const std::string &amp;s, unsigned long long int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long int &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to unsigned long long int, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5269f51d3787ec1a0eb839784b1dba0"></a><!-- doxytag: member="uripp::convert" ref="e5269f51d3787ec1a0eb839784b1dba0" args="(const std::string &amp;s, double &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to double, returning true if set, which is when the string is not empty or all isspace. isspace before and/or after value OK. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>on conversion error </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cbd143a3a240e2fb57eda08e9beb1473"></a><!-- doxytag: member="uripp::convert" ref="cbd143a3a240e2fb57eda08e9beb1473" args="(const std::string &amp;s, std::string &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::convert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to trimmed string, returning true if set, which is when the string is not empty or all isspace. 
</div>
</div><p>
<a class="anchor" name="c022bda4680769c731e205c24133824d"></a><!-- doxytag: member="uripp::isspaces" ref="c022bda4680769c731e205c24133824d" args="(const char *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::isspaces           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if string is empty or all isspace. 
</div>
</div><p>
<a class="anchor" name="a09e4869830939777e1bc2d2cd850d4e"></a><!-- doxytag: member="uripp::parse_hex" ref="a09e4869830939777e1bc2d2cd850d4e" args="(const std::string &amp;s, size_t pos, char &amp;chr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API uripp::parse_hex           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>chr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse hex chars at pos, returning success, and set the char and advance first on success. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Fri May 1 11:16:43 2009 for uripp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
