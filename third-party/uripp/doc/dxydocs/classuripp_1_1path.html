<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uripp: uripp::path Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceuripp.html">uripp</a>::<a class="el" href="classuripp_1_1path.html">path</a></div>
<h1>uripp::path Class Reference</h1><!-- doxytag: class="uripp::path" --><a href="classuripp_1_1path-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
URI path component. 
<p>
Note that there are potential ambiguities when using ":" and "//" in paths in URIs (see RFC).<p>
Syntax: Segments are pct-decoded after parsing. <pre>
 ALPHA      =  x41-5A | x61-7A   ; A-Z | a-z
 DIGIT      =  x30-39             ; 0-9
 sub-delims = "!" | "$" | "&amp;" | "'" | "(" | ")" | "*"
            | "+" | "," | ";" | "="
 unreserved = ALPHA | DIGIT | "-" | "." | "_" | "~"
 pchar      = unreserved | pct-encoded | sub-delims | ":" | "@"
 segment    = *pchar
 path       = *( "/" segment )
 </pre> <dl compact><dt><b>See also:</b></dt><dd><a href="http://tools.ietf.org/html/rfc3986#section-3.3">http://tools.ietf.org/html/rfc3986#section-3.3</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4957d93647c79c8549367a3f17a24437"></a><!-- doxytag: member="uripp::path::segments_type" ref="4957d93647c79c8549367a3f17a24437" args="" -->
typedef std::list&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#4957d93647c79c8549367a3f17a24437">segments_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">segments type <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="caeaa71bcde374738ed7a22c84619095"></a><!-- doxytag: member="uripp::path::const_iterator" ref="caeaa71bcde374738ed7a22c84619095" args="" -->
typedef segments_type::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#caeaa71bcde374738ed7a22c84619095">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">segments const iterator type <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#b885cc317a73ebb29f76f15e6b25b536">path</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#582ad2777cdace5bac6abd88374c3f00">path</a> (const std::string &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4abc21525f8b84c841ed8a7695c2c6fa"></a><!-- doxytag: member="uripp::path::empty" ref="4abc21525f8b84c841ed8a7695c2c6fa" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#4abc21525f8b84c841ed8a7695c2c6fa">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if empty and not absolute. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ec9084bd752b1d64ef5ae75595417122"></a><!-- doxytag: member="uripp::path::absolute" ref="ec9084bd752b1d64ef5ae75595417122" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#ec9084bd752b1d64ef5ae75595417122">absolute</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if absolute, meaning path begins with "/". <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="51c9543841750f389e270864f1e8bf3f"></a><!-- doxytag: member="uripp::path::absolute" ref="51c9543841750f389e270864f1e8bf3f" args="(bool v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#51c9543841750f389e270864f1e8bf3f">absolute</a> (bool v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether absolute or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="570c6bee473e653391b6ad5c203ca5d5"></a><!-- doxytag: member="uripp::path::is_directory" ref="570c6bee473e653391b6ad5c203ca5d5" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#570c6bee473e653391b6ad5c203ca5d5">is_directory</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if a directory, meaning the path ends in a "/". <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36525d01a352fcd7dde4fdc89dfa3762"></a><!-- doxytag: member="uripp::path::is_directory" ref="36525d01a352fcd7dde4fdc89dfa3762" args="(bool v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#36525d01a352fcd7dde4fdc89dfa3762">is_directory</a> (bool v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether a directory or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#f269e7ab6db6db9e7540f75827ebc054">front</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#9c35a352c4ee8862e24f8227a62310e3">back</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#675ce082011118001c9aa90375663fa0">match_prefix</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;rhs) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#39ecfd217e5e9569c400d562ebd9601a">pop_front</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#4614c0512dc1d983448b8349dd436912">pop_back</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;back)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86f797e4d2eeca005fef54df69a70487"></a><!-- doxytag: member="uripp::path::clear" ref="86f797e4d2eeca005fef54df69a70487" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#86f797e4d2eeca005fef54df69a70487">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear segments and reset absolute and is_directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e00ec537f9656e4778f1ed3072bb6de0"></a><!-- doxytag: member="uripp::path::size" ref="e00ec537f9656e4778f1ed3072bb6de0" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>size</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eab8ca3848a8e4595d16d2fb08be1a1c"></a><!-- doxytag: member="uripp::path::operator==" ref="eab8ca3848a8e4595d16d2fb08be1a1c" args="(const path &amp;rhs) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#eab8ca3848a8e4595d16d2fb08be1a1c">operator==</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of segments. Equal operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#4d4cfd6cb27b852e299cd16ca5f36745">operator!=</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;rhs) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#b4e2576342fbc36249b039346e4a33fc">operator&lt;</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;rhs) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3e20a495f56bd78ff6a363e9cf937592"></a><!-- doxytag: member="uripp::path::operator+" ref="3e20a495f56bd78ff6a363e9cf937592" args="(const std::string &amp;rhs) const " -->
<a class="el" href="classuripp_1_1path.html">path</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#3e20a495f56bd78ff6a363e9cf937592">operator+</a> (const std::string &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append unencoded segment and reset is_directory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classuripp_1_1path.html">path</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#448f709ea052517548c153b1f9bee485">operator+=</a> (const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="596cc6c06bae08ba8241728599d88263"></a><!-- doxytag: member="uripp::path::operator+" ref="596cc6c06bae08ba8241728599d88263" args="(const path &amp;rhs) const " -->
<a class="el" href="classuripp_1_1path.html">path</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#596cc6c06bae08ba8241728599d88263">operator+</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append path and set is_directory according to rhs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f9fce467ca7322e162c07d9608a45f70"></a><!-- doxytag: member="uripp::path::operator+=" ref="f9fce467ca7322e162c07d9608a45f70" args="(const path &amp;rhs)" -->
<a class="el" href="classuripp_1_1path.html">path</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#f9fce467ca7322e162c07d9608a45f70">operator+=</a> (const <a class="el" href="classuripp_1_1path.html">path</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append path and set is_directory according to rhs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="08e3e1300da493f5879496e6dfb0cea1"></a><!-- doxytag: member="uripp::path::encoding" ref="08e3e1300da493f5879496e6dfb0cea1" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#08e3e1300da493f5879496e6dfb0cea1">encoding</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate encoded string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67ff2b3a9d6d4998df9f3442a6ebcc5a"></a><!-- doxytag: member="uripp::path::begin" ref="67ff2b3a9d6d4998df9f3442a6ebcc5a" args="() const " -->
<a class="el" href="classuripp_1_1path.html#caeaa71bcde374738ed7a22c84619095">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#67ff2b3a9d6d4998df9f3442a6ebcc5a">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get iterator at beginning. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac8dc97f3abb40df4833079145bb9258"></a><!-- doxytag: member="uripp::path::end" ref="ac8dc97f3abb40df4833079145bb9258" args="() const " -->
<a class="el" href="classuripp_1_1path.html#caeaa71bcde374738ed7a22c84619095">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#ac8dc97f3abb40df4833079145bb9258">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get iterator at end. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b60dbe747937ad7720d9ac5567f584ed"></a><!-- doxytag: member="uripp::path::SEPARATOR_CHAR" ref="b60dbe747937ad7720d9ac5567f584ed" args="" -->
static const char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#b60dbe747937ad7720d9ac5567f584ed">SEPARATOR_CHAR</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">separator ('/') <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool URIPP_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuripp_1_1path.html#6fa8f509a11c7367c1d2c620b0848395">parse</a> (std::string::const_iterator &amp;first, std::string::const_iterator last, <a class="el" href="classuripp_1_1path.html">path</a> &amp;v, std::string *errs)</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b885cc317a73ebb29f76f15e6b25b536"></a><!-- doxytag: member="uripp::path::path" ref="b885cc317a73ebb29f76f15e6b25b536" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uripp::path::path           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct. 
</div>
</div><p>
<a class="anchor" name="582ad2777cdace5bac6abd88374c3f00"></a><!-- doxytag: member="uripp::path::path" ref="582ad2777cdace5bac6abd88374c3f00" args="(const std::string &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uripp::path::path           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct from encoded string. For example "/foo/bar" or "/foo/ba%20r". Empty segments are removed, i.e. "a//b" becomes "a/b". See <code><a class="el" href="classuripp_1_1path.html#6fa8f509a11c7367c1d2c620b0848395">parse()</a></code> for less strict construction. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>if invalid encoding </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9c35a352c4ee8862e24f8227a62310e3"></a><!-- doxytag: member="uripp::path::back" ref="9c35a352c4ee8862e24f8227a62310e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; uripp::path::back           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get back segment. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::out_of_range</em>&nbsp;</td><td>if empty </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f269e7ab6db6db9e7540f75827ebc054"></a><!-- doxytag: member="uripp::path::front" ref="f269e7ab6db6db9e7540f75827ebc054" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; uripp::path::front           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get front segment. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::out_of_range</em>&nbsp;</td><td>if empty </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="675ce082011118001c9aa90375663fa0"></a><!-- doxytag: member="uripp::path::match_prefix" ref="675ce082011118001c9aa90375663fa0" args="(const path &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uripp::path::match_prefix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuripp_1_1path.html">path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if the given other URI path is a prefix of this. Must match whether absolute as well. 
</div>
</div><p>
<a class="anchor" name="4d4cfd6cb27b852e299cd16ca5f36745"></a><!-- doxytag: member="uripp::path::operator!=" ref="4d4cfd6cb27b852e299cd16ca5f36745" args="(const path &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uripp::path::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuripp_1_1path.html">path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Not equal operator. 
</div>
</div><p>
<a class="anchor" name="448f709ea052517548c153b1f9bee485"></a><!-- doxytag: member="uripp::path::operator+=" ref="448f709ea052517548c153b1f9bee485" args="(const std::string &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuripp_1_1path.html">path</a>&amp; uripp::path::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append unencoded segment and reset is_directory. 
</div>
</div><p>
<a class="anchor" name="b4e2576342fbc36249b039346e4a33fc"></a><!-- doxytag: member="uripp::path::operator&lt;" ref="b4e2576342fbc36249b039346e4a33fc" args="(const path &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uripp::path::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuripp_1_1path.html">path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Less operator. Examines the following in order: <ol>
<li>
relative are less than absolute </li>
<li>
lexicographical comparison of segments </li>
<li>
non-directories are less than directories</li>
</ol>

</div>
</div><p>
<a class="anchor" name="4614c0512dc1d983448b8349dd436912"></a><!-- doxytag: member="uripp::path::pop_back" ref="4614c0512dc1d983448b8349dd436912" args="(const path &amp;back)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uripp::path::pop_back           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuripp_1_1path.html">path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>back</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the back of the path if it matches the argument (including whether directory or not) and return whether removed/matched. Note that if this starts as a directory it stays a directory. If back is absolute and it does not match all of this or this is not absolute then there is no match. 
</div>
</div><p>
<a class="anchor" name="39ecfd217e5e9569c400d562ebd9601a"></a><!-- doxytag: member="uripp::path::pop_front" ref="39ecfd217e5e9569c400d562ebd9601a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uripp::path::pop_front           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pop front segment and reset absolute. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="6fa8f509a11c7367c1d2c620b0848395"></a><!-- doxytag: member="uripp::path::parse" ref="6fa8f509a11c7367c1d2c620b0848395" args="(std::string::const_iterator &amp;first, std::string::const_iterator last, path &amp;v, std::string *errs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool URIPP_API parse           </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuripp_1_1path.html">path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>errs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse URI path, returning whether found or not and advancing first and setting path if found. Does not skip leading space.<p>
If <code>errs</code> is specified the following take place:<ul>
<li>
Errors in decoding segments do not cause an immediate false return and and error message is reported in the error string <code>errs</code>. The segment is used without decoding (i.e. assumes an unencoded ''). </li>
</ul>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Fri May 1 11:16:43 2009 for uripp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
